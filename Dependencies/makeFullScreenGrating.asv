
%% Create an oversized Full Screen Grating for the Figure
[x,y]=meshgrid(-Par.Screenx:Par.Screenx);
x_ori =x*cosd(Par.FigOrient)+y*sind(Par.FigOrient);
OversizedGrating =sin(2*pi*(1/Par.Period)*x_ori + Log.FigPhase(Trial));

%% Adjust to max and min Luminance of the Screen
OversizedGrating =  OversizedGrating - min( OversizedGrating(:)); % set range of OversizedGrating between [0, inf)
OversizedGrating =  OversizedGrating ./ max( OversizedGrating(:)) ; % set range of OversizedGrating between [0, 1]
%OversizedGrating =  OversizedGrating .* diff([Par.minlum Par.maxlum]) ; % set range of OversizedGrating between [0, LuminanceRange]
%OversizedGrating =  OversizedGrating + Par.minlum; % shift range of OversizedGrating to Par.minlum
%OversizedGratingRGB = eval([gammaconversion '(OversizedGrating,''lum2rgb'')']);

%% Morph the grating, convert Cartesian to spherical coordinates
% In image space, x and y are width and height of monitor and z is the distance from the eye. I want Theta to correspond to azimuth and Phi to
% correspond to elevation, but these are measured from the x-axis and x-y plane, respectively. So I need to exchange the axes prior to
% converting to spherical coordinates: orig (image) -> for conversion to spherical coords
% Z -> X          X -> Y              Y -> Z
ScreenDistanceTop = Par.ScreenDistanceBottom - (Par.ScreenHeight*sin(deg2rad(90-Par.ScreenAngle))); % Calculate the Distance of the Screen at the top of the Screen (only different from the distance to the bottom if the Screen is angled, so not at 90 degrees)
[xi,yi] = meshgrid(1:Par.Screenx,1:Par.Screeny);
cart_pointsX = -Par.MouseposX + (Par.ScreenWidth/Par.Screenx).*xi;
cart_pointsY = Par.ScreenHeight-Par.MouseposY - (Par.ScreenHeight/Par.Screeny).*yi;
cart_pointsZ = Par.ScreenDistanceBottom + ((Par.ScreenDistanceBottom-ScreenDistanceTop)/Par.Screeny).*yi;
[~, sphr_Horiz, ~] = cart2sph(cart_pointsZ,cart_pointsX,cart_pointsY);
[~, sphr_Vert, ~] = cart2sph(cart_pointsZ,cart_pointsY,cart_pointsX); 

rangeOversizedX = size(OversizedGrating,1)*Par.RadPerPix;
rangeOversizedY = size(OversizedGrating,2)*Par.RadPerPix;

anglesOversizedX = -(rangeOversizedX/2-Par.RadPerPix) : Par.RadPerPix : rangeOversizedX/2;
anglesOversizedY = -(rangeOversizedY/2-Par.RadPerPix) : Par.RadPerPix : rangeOversizedY/2;

[xang, yang] = meshgrid(anglesOversizedX, anglesOversizedY*-1);
morphedGrating = interp2(xang, yang, OversizedGrating, sphr_Vert, sphr_Horiz);


%% now show in Cogent TEMPORARY
cgloadlib
cgshut
%Screen
cgopen(Par.Screenx, Par.Screeny, 32,Par.Refresh , 0)
Mv = reshape(morphedGrating',numel(morphedGrating),1);
Mv = [Mv,Mv,Mv];
cgloadarray(1,Par.Screenx,Par.Screeny,Mv)
cgdrawsprite(1,0,0)
cgsetsprite(0)
cgflip(Par.grey)